"case IntelIntDir(d) => \"int %d\" format d"
"case IntelAscizDir(s) => \"asciz \\\"%s\\\"\" format escapeChars(s)"
"case IntelSyntaxDir(s) => \"intel_syntax %s\" format s"
"case IntelTextDir => \"text\""
"private def coreEightFormat(s: String, end: String)(implicit size: IntelSize): String ="
"private val callee: List[IntelRegister] = List(R12, R13, R14, R15)"
"private val caller: List[IntelRegister] = List(RDI, RSI, RDX, RCX, R8, R9)"
"val listFuncArgs = List(RDI, RSI, RDX, RCX, R8, R9)"
"private val mapToRegister: HashMap[String, IntelRegister] = HashMap.empty"
"private val mapToAddr: HashMap[String, IntelAddr] = HashMap.empty"
"def formatProgram(prog: List[IntelPhaseWrapper]): Unit = {"
"private def formatDirective(dir: IntelDirective): String = {"
"private def formatInstruction(i: IntelInstruction): String = {"
"private var isIndented = false"
"private val tab = \" \""
"def genShortList(): List[IntelRegister] = shortList"
"def calcStackOps(size: Int): Int = 0.max(size - listFuncArgs.length)"
"private val qwordSize: Int = 8"
"private val stackFuncPushes: Int = 2"
"private var currOffset: Int = 0"
"private val regAssign: HashMap[Int, IntelRegister] = HashMap.empty"
"private def escapeChars(s: String): String = s"
"private def genFuncArgsPushPopList(args: Int): List[IntelRegister] ="
"private def genRSPDeRef(offset: Int): IntelWordPtr = IntelWordPtr("
"mapToRegister.getOrElse(s,"
"case IntelLabel(s) => isIndented = true; s + \":\""
"case _ => \"\""
"leftOver = rs"
"val args = List.fill(size)(0)"
"IntelDerefReg1(RSP, IntelImmInt(currOffset * qwordSize))"
"case (id, s) =>"
"case IdentReg(id, t) => identPrefix"
"throw new BackendErrorBuilder("
"private def regSetUpHelper(regs: List[(Int, Int)], prefix: String): Unit ="
"def allocate(tmpReg: Register): IntelAddr = {"
"case IntelRet => tab + \"ret\""
"case IntelCDQ => tab + \"cdq\""
"writer.write(c match {"
"prog.foreach(wrap => {"
"case TempReg(id, t) => tempPrefix"
"case IntelDerefReg1(RSP, IntelImmInt(num)) =>"
"genFuncArgsList(size).map(_ match {"
"implicit val intelSize: IntelSize = IntelQWORD"
"genFuncArgsList(size)"
"getOffsetSize(): Int = currOffset.abs"
"genFuncArgsList(size: Int): List[IntelAddr] = {"
"currOffset -= s"
"genImmIntOffset(size: Int): IntelImmInt = IntelImmInt(qwordSize * size)"
"IntelWordPtr(IntelDerefReg1(RSP, IntelImmInt(qwordSize * offset)))"
"case IntelGloblDir(s) => \"globl %s\" format getOperandFormat(s)"
